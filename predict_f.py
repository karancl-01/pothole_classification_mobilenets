# -*- coding: utf-8 -*-
"""predict_f

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1AnPt8ODmszwURnApv-_pBjWhy0qJHRc0
"""

import torch
import torch.nn as nn
from torchvision import models, transforms
from PIL import Image
import os
# Import the necessary library for Colab file uploads
from google.colab import files
import matplotlib.pyplot as plt
import numpy as np

# --- 1. PREDICTION FUNCTION (No changes needed here) ---
def predict(image_path, model, device, class_names):
    """
    Takes an image path and a trained model, then returns the predicted class and displays the image.
    """
    model.eval()
    image = Image.open(image_path).convert("RGB")

    prediction_transforms = transforms.Compose([
        transforms.Resize(256),
        transforms.CenterCrop(224),
        transforms.ToTensor(),
        transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])
    ])

    image_tensor = prediction_transforms(image).unsqueeze(0)
    image_tensor = image_tensor.to(device)

    with torch.no_grad():
        outputs = model(image_tensor)
        _, preds = torch.max(outputs, 1)
        predicted_class = class_names[preds[0]]

    # --- Display the image with its prediction ---

    print(f'Prediction: {predicted_class}')



    return predicted_class

# --- 2. MODEL AND ENVIRONMENT SETUP ---
# This part defines the model architecture so we can load the weights.
print("Setting up the model architecture...")
device = torch.device("cuda:0" if torch.cuda.is_available() else "cpu")
class_names = ['normal', 'pothole']

# Load the MobileNetV2 architecture.
model = models.mobilenet_v2()

# Replace the final layer to match our trained model (2 output classes).
num_ftrs = model.classifier[1].in_features
model.classifier[1] = nn.Linear(in_features=num_ftrs, out_features=len(class_names))

# --- 3. LOAD THE TRAINED WEIGHTS ---
# Load the saved state_dict (the "brain" of your trained model).
model_weights_path = 'pothole_classifier_model.pth'
if not os.path.exists(model_weights_path):
    print(f"Error: Model weights file not found at '{model_weights_path}'")
    print("Please make sure the 'pothole_classifier_model.pth' file is uploaded to your Colab session.")
else:
    try:
        model.load_state_dict(torch.load(model_weights_path, map_location=device))
        model = model.to(device)
        print("Model weights loaded successfully.")

        # --- 4. INTERACTIVE IMAGE UPLOAD AND PREDICTION ---
        print("\nPlease upload an image file to classify.")
        # This function creates an interactive upload button in the cell's output.
        uploaded = files.upload()

        # Check if the user uploaded any files.
        if uploaded:
            # Get the filename of the first uploaded file.
            image_name = next(iter(uploaded))
            print(f"\nUser uploaded image: {image_name}")

            # Make the prediction using the function and the uploaded image.
            prediction_result = predict(image_name, model, device, class_names)
            print(f"\n--> Final Prediction: {prediction_result}")
        else:
            print("\nNo file was uploaded.")

    except Exception as e:
        print(f"An error occurred during model loading or prediction: {e}")

"""### **How to Use This File**

1.  **Save the Model from Your Notebook:** Make sure you have run the cell in your Jupyter Notebook that saves the trained model. This will create a file named **`pothole_classifier_model.pth`**. Download this file to your computer.

2.  **Save the Prediction Script:** Save the code above as a file named **`predict.py`** on your computer.

3.  **Organize Your Files:** Place both `predict.py` and `pothole_classifier_model.pth` in the **same folder**. Also, place any image you want to test in that same folder.

4.  **Run from the Command Line:** Open a terminal or command prompt, navigate to that folder, and run the script, providing the name of the image you want to classify.

    ```bash
    # Example for an image named 'road_photo.jpg'
    python predict.py road_photo.jpg
    ```
    **Expected Output:**
    


  ```
"""